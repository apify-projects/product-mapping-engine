export = BrowserPool;
/**
 * The `BrowserPool` class is the most important class of the `browser-pool` module.
 * It manages opening and closing of browsers and their pages and its constructor
 * options allow easy configuration of the browsers' and pages' lifecycle.
 *
 * The most important and useful constructor options are the various lifecycle hooks.
 * Those allow you to sequentially call a list of (asynchronous) functions at each
 * stage of the browser / page lifecycle.
 *
 * **Example:**
 * ```js
 * const { BrowserPool, PlaywrightPlugin } = require('browser-pool');
 * const playwright = require('playwright');
 *
 * const browserPool = new BrowserPool({
 *     browserPlugins: [ new PlaywrightPlugin(playwright.chromium)],
 *     preLaunchHooks: [(pageId, launchContext) => {
 *         // do something before a browser gets launched
 *         launchContext.launchOptions.headless = false;
 *     }],
 *     postLaunchHooks: [(pageId, browserController) => {
 *         // manipulate the browser right after launch
 *         console.dir(browserController.browser.contexts());
 *     }],
 *     prePageCreateHooks: [(pageId, browserController) => {
 *         if (pageId === 'my-page') {
 *             // make changes right before a specific page is created
 *         }
 *     }],
 *     postPageCreateHooks: [async (page, browserController) => {
 *         // update some or all new pages
 *         await page.evaluate(() => {
 *             // now all pages will have 'foo'
 *             window.foo = 'bar'
 *         })
 *     }],
 *     prePageCloseHooks: [async (page, browserController) => {
 *         // collect information just before a page closes
 *         await page.screenshot();
 *     }],
 *     postPageCloseHooks: [(pageId, browserController) => {
 *         // clean up or log after a job is done
 *         console.log('Page closed: ', pageId)
 *     }]
 * });
 * ```
 *
 * @param {object} options
 * @param {BrowserPlugin[]} options.browserPlugins
 *  Browser plugins are wrappers of browser automation libraries that
 *  allow `BrowserPool` to control browsers with those libraries.
 *  `browser-pool` comes with a `PuppeteerPlugin` and a `PlaywrightPlugin`.
 * @param {number} [options.maxOpenPagesPerBrowser=20]
 *  Sets the maximum number of pages that can be open in a browser at the
 *  same time. Once reached, a new browser will be launched to handle the excess.
 * @param {number} [options.retireBrowserAfterPageCount=100]
 *  Browsers tend to get bloated after processing a lot of pages. This option
 *  configures the number of processed pages after which the browser will
 *  automatically retire and close. A new browser will launch in its place.
 * @param {number} [options.operationTimeoutSecs=15]
 *  As we know from experience, async operations of the underlying libraries,
 *  such as launching a browser or opening a new page, can get stuck.
 *  To prevent `BrowserPool` from getting stuck, we add a timeout
 *  to those operations and you can configure it with this option.
 * @param {number} [options.closeInactiveBrowserAfterSecs=300]
 *  Browsers normally close immediately after their last page is processed.
 *  However, there could be situations where this does not happen. Browser Pool
 *  makes sure all inactive browsers are closed regularly, to free resources.
 * @param {function[]} [options.preLaunchHooks]
 *  Pre-launch hooks are executed just before a browser is launched and provide
 *  a good opportunity to dynamically change the launch options.
 *  The hooks are called with two arguments:
 *  `pageId`: `string` and `launchContext`: {@link LaunchContext}
 * @param {function[]} [options.postLaunchHooks]
 *  Post-launch hooks are executed as soon as a browser is launched.
 *  The hooks are called with two arguments:
 *  `pageId`: `string` and `browserController`: {@link BrowserController}
 *  To guarantee order of execution before other hooks in the same browser,
 *  the {@link BrowserController} methods cannot be used until the post-launch
 *  hooks complete. If you attempt to call `await browserController.close()` from
 *  a post-launch hook, it will deadlock the process. This API is subject to change.
 * @param {function[]} [options.prePageCreateHooks]
 *  Pre-page-create hooks are executed just before a new page is created. They
 *  are useful to make dynamic changes to the browser before opening a page.
 *  The hooks are called with two arguments:
 *  `pageId`: `string`, `browserController`: {@link BrowserController} and
 *  `pageOptions`: `object|undefined` - This only works if the underlying `BrowserController` supports new page options.
 *  So far, new page options are only supported by `PlaywrightController`.
 *  If the page options are not supported by `BrowserController` the `pageOptions` argument is `undefined`.
 * @param {function[]} [options.postPageCreateHooks]
 *  Post-page-create hooks are called right after a new page is created
 *  and all internal actions of Browser Pool are completed. This is the
 *  place to make changes to a page that you would like to apply to all
 *  pages. Such as injecting a JavaScript library into all pages.
 *  The hooks are called with two arguments:
 *  `page`: `Page` and `browserController`: {@link BrowserController}
 * @param {function[]} [options.prePageCloseHooks]
 *  Pre-page-close hooks give you the opportunity to make last second changes
 *  in a page that's about to be closed, such as saving a snapshot or updating
 *  state.
 *  The hooks are called with two arguments:
 *  `page`: `Page` and `browserController`: {@link BrowserController}
 * @param {function[]} [options.postPageCloseHooks]
 *  Post-page-close hooks allow you to do page related clean up.
 *  The hooks are called with two arguments:
 *  `pageId`: `string` and `browserController`: {@link BrowserController}
 */
declare class BrowserPool extends EventEmitter {
    constructor(options?: {});
    browserPlugins: unknown[];
    maxOpenPagesPerBrowser: number;
    retireBrowserAfterPageCount: number;
    operationTimeoutMillis: number;
    closeInactiveBrowserAfterMillis: number;
    preLaunchHooks: unknown[];
    postLaunchHooks: unknown[];
    prePageCreateHooks: unknown[];
    postPageCreateHooks: unknown[];
    prePageCloseHooks: unknown[];
    postPageCloseHooks: unknown[];
    pageCounter: number;
    pages: Map<any, any>;
    pageIds: WeakMap<object, any>;
    activeBrowserControllers: Set<any>;
    retiredBrowserControllers: Set<any>;
    pageToBrowserController: WeakMap<object, any>;
    browserKillerInterval: NodeJS.Timeout;
    /**
     * Opens a new page in one of the running browsers or launches
     * a new browser and opens a page there, if no browsers are active,
     * or their page limits have been exceeded.
     *
     * @param {object} options
     * @param {string} [options.id]
     *  Assign a custom ID to the page. If you don't a random string ID
     *  will be generated.
     * @param {object} [options.pageOptions]
     *  Some libraries (Playwright) allow you to open new pages with specific
     *  options. Use this property to set those options.
     * @param {BrowserPlugin} [options.browserPlugin]
     *  Choose a plugin to open the page with. If none is provided,
     *  one of the pool's available plugins will be used.
     *
     *  It must be one of the plugins browser pool was created with.
     *  If you wish to start a browser with a different configuration,
     *  see the `newPageInNewBrowser` function.
     * @return {Promise<Page>}
     */
    newPage(options?: {
        id?: string | undefined;
        pageOptions?: object | undefined;
        browserPlugin?: any;
    }): Promise<any>;
    /**
     * Unlike {@link newPage}, `newPageInNewBrowser` always launches a new
     * browser to open the page in. Use the `launchOptions` option to
     * configure the new browser.
     *
     * @param {object} options
     * @param {string} [options.id]
     *  Assign a custom ID to the page. If you don't a random string ID
     *  will be generated.
     * @param {object} [options.pageOptions]
     *  Some libraries (Playwright) allow you to open new pages with specific
     *  options. Use this property to set those options.
     * @param {object} [options.launchOptions]
     *  Options that will be used to launch the new browser.
     * @param {BrowserPlugin} [options.browserPlugin]
     *  Provide a plugin to launch the browser. If none is provided,
     *  one of the pool's available plugins will be used.
     *
     *  If you configured `BrowserPool` to rotate multiple libraries,
     *  such as both Puppeteer and Playwright, you should always set
     *  the `browserPlugin` when using the `launchOptions` option.
     *
     *  The plugin will not be added to the list of plugins used by
     *  the pool. You can either use one of those, to launch a specific
     *  browser, or provide a completely new configuration.
     * @return {Promise<Page>}
     */
    newPageInNewBrowser(options?: {
        id?: string | undefined;
        pageOptions?: object | undefined;
        launchOptions?: object | undefined;
        browserPlugin?: any;
    }): Promise<any>;
    /**
     * Opens new pages with all available plugins and returns an array
     * of pages in the same order as the plugins were provided to `BrowserPool`.
     * This is useful when you want to run a script in multiple environments
     * at the same time, typically in testing or website analysis.
     *
     * **Example:**
     * ```js
     * const browserPool = new BrowserPool({
     *     browserPlugins: [
     *         new PlaywrightPlugin(playwright.chromium),
     *         new PlaywrightPlugin(playwright.firefox),
     *         new PlaywrightPlugin(playwright.webkit),
     *         new PuppeteerPlugin(puppeteer),
     *     ]
     * });
     *
     * const pages = await browserPool.newPageWithEachPlugin();
     * const [chromiumPage, firefoxPage, webkitPage, puppeteerPage] = pages;
     * ```
     *
     * @param {object[]} optionsList
     * @return {Promise<Page[]>}
     */
    newPageWithEachPlugin(optionsList?: object[]): Promise<any[]>;
    /**
     * Retrieves a {@link BrowserController} for a given page. This is useful
     * when you're working only with pages and need to access the browser
     * manipulation functionality.
     *
     * You could access the browser directly from the page,
     * but that would circumvent `BrowserPool` and most likely
     * cause weird things to happen, so please always use `BrowserController`
     * to control your browsers. The function returns `undefined` if the
     * browser is closed.
     *
     * @param page {Page} - Browser plugin page
     * @return {?BrowserController}
     */
    getBrowserControllerByPage(page: any): any | null;
    /**
     * If you provided a custom ID to one of your pages or saved the
     * randomly generated one, you can use this function to retrieve
     * the page. If the page is no longer open, the function will
     * return `undefined`.
     *
     * @param {string} id
     * @return {?Page}
     */
    getPage(id: string): any | null;
    /**
     * Page IDs are used throughout `BrowserPool` as a method of linking
     * events. You can use a page ID to track the full lifecycle of the page.
     * It is created even before a browser is launched and stays with the page
     * until it's closed.
     *
     * @param {Page} page
     * @return {string}
     */
    getPageId(page: any): string;
    /**
     * @param {string} pageId
     * @param {BrowserController} browserController
     * @param {object} pageOptions
     * @return {Promise<Page>}
     * @private
     */
    private _createPageForBrowser;
    /**
     * Removes a browser controller from the pool. The underlying
     * browser will be closed after all its pages are closed.
     * @param {BrowserController} browserController
     *
     */
    retireBrowserController(browserController: any): void;
    /**
     * Removes a browser from the pool. It will be
     * closed after all its pages are closed.
     * @param {Page} page
     */
    retireBrowserByPage(page: any): void;
    /**
     * Removes all active browsers from the pool. The browsers will be
     * closed after all their pages are closed.
     */
    retireAllBrowsers(): void;
    /**
     * Closes all managed browsers without waiting for pages to close.
     * @return {Promise<void>}
     */
    closeAllBrowsers(): Promise<void>;
    /**
     * Closes all managed browsers and tears down the pool.
     * @return {Promise<void>}
     */
    destroy(): Promise<void>;
    _teardown(): void;
    /**
     * @return {Set<BrowserController>}
     * @private
     */
    private _getAllBrowserControllers;
    /**
     * @param {string} pageId
     * @param {object} options
     * @param {BrowserPlugin} options.browserPlugin
     * @param {object} [options.launchOptions]
     * @return {Promise<BrowserController>}
     * @private
     */
    private _launchBrowser;
    /**
     * Picks plugins round robin.
     * @return {BrowserPlugin}
     * @private
     */
    private _pickBrowserPlugin;
    /**
     * @param {BrowserPlugin} browserPlugin
     * @return {BrowserController}
     * @private
     */
    private _pickBrowserWithFreeCapacity;
    _closeInactiveRetiredBrowsers(): Promise<void>;
    /**
     * @param {Page} page
     * @private
     */
    private _overridePageClose;
    /**
     * @param {function[]} hooks
     * @param {...*} args
     * @return {Promise<void>}
     * @private
     */
    private _executeHooks;
    /**
     * @param {BrowserController} browserController
     * @private
     */
    private _closeRetiredBrowserWithNoPages;
}
import EventEmitter = require("events");
//# sourceMappingURL=browser-pool.d.ts.map